#include <core.p4>
#include <tna.p4>

#include "../common/headers.p4"
#include "../common/util.p4"

struct my_hdr_t {
  ethernet_h ethernet;
  ipv4_h     ipv4;
  udp_h      udp;
  tcp_h      tcp;
}

header eg_mirror_h {
}

struct ig_md_t {
  bit<32> fingerprint;
}

struct eg_md_t {
}

// generated by StructDefinitionFactory_140480949615056 start
// generated by StructDefinitionFactory_140480949615056 end


parser SwitchIngressParser(
    packet_in pkt,
    out my_hdr_t hdr,
    out ig_md_t ig_md,
    out ingress_intrinsic_metadata_t ig_intr_md
  ) {

  TofinoIngressParser() tofino_parser;

  state start {
    tofino_parser.apply(pkt, ig_intr_md);
    transition parse_ethernet;
  }

  state parse_ethernet {
    pkt.extract(hdr.ethernet);
    transition select (hdr.ethernet.ether_type) {
      ETHERTYPE_IPV4: parse_ipv4;
      default:        accept;
    }
  }

  state parse_ipv4 {
    pkt.extract(hdr.ipv4);
    transition select (hdr.ipv4.ihl, hdr.ipv4.protocol) {
      (5, IP_PROTOCOLS_UDP): parse_udp;
      (5, IP_PROTOCOLS_TCP): parse_tcp;
      default:               accept;
    }
  }

  state parse_udp {
    pkt.extract(hdr.udp);
    transition accept;
  }

  state parse_tcp {
    pkt.extract(hdr.tcp);
    transition accept;
  }
}

control SwitchIngress(
    inout my_hdr_t hdr,
    inout ig_md_t ig_md,
    in ingress_intrinsic_metadata_t ig_intr_md,
    in ingress_intrinsic_metadata_from_parser_t ig_prsr_md,
    inout ingress_intrinsic_metadata_for_deparser_t ig_dprsr_md,
    inout ingress_intrinsic_metadata_for_tm_t ig_tm_md) {

  action send(PortId_t egress_port) {
    ig_tm_md.ucast_egress_port = egress_port;
  }

  action drop() {
    ig_dprsr_md.drop_ctl = 0x1;
  }

  table tab_forward {
    key = {
      ig_intr_md.ingress_port : exact;
    }

    actions = {
      send;
      @defaultonly drop;
    }

    const default_action = drop();
    size = 512;
  }

  // generated by SwitchEgressFactory140480949616112 start
  // generated by _ValueFactory140480949612800 start
  bit<32> var_task_mask;
  bit<32> var_index_2880;
  bit<32> var_count_29d0;
  const bit<32> const_count_27f0 = 32w1;
  const bit<32> const_50_2ac0 = 32w50;
  const bit<32> const_UNUSUAL_EGRESS_PORT_2be0 = UNUSUAL_EGRESS_PORT;
  // generated by _ValueFactory140480949612800 end

  // generated by _TableFactory140480949613040 start
  // generated by _CountMinSketch_140480949613568 start
  bit<32> table_reduce_table_2940_index;
  bit<32> table_reduce_table_2940_value;
  CRCPolynomial<bit<32>>(0x3577, true, false, false, 0, 0) table_reduce_table_2940_poly0;
  Hash<bit<32>>(HashAlgorithm_t.CRC32, table_reduce_table_2940_poly0) table_reduce_table_2940_hash0;
  Register<bit<32>, bit<32>>(16384, 0) table_reduce_table_2940_reg0;
  RegisterAction<bit<32>, bit<32>, bit<32>>(table_reduce_table_2940_reg0) table_reduce_table_2940_upd0 = {
    void apply(inout bit<32> val, out bit<32> res) {
      res = val;
      val = val + 1;
    }
  };
  RegisterAction<bit<32>, bit<32>, bit<32>>(table_reduce_table_2940_reg0) table_reduce_table_2940_get0 = {
    void apply(inout bit<32> val, out bit<32> res) {
      res = val;
    }
  };
  CRCPolynomial<bit<32>>(0x35ee, true, false, false, 0, 0) table_reduce_table_2940_poly1;
  Hash<bit<32>>(HashAlgorithm_t.CRC32, table_reduce_table_2940_poly1) table_reduce_table_2940_hash1;
  Register<bit<32>, bit<32>>(16384, 0) table_reduce_table_2940_reg1;
  RegisterAction<bit<32>, bit<32>, bit<32>>(table_reduce_table_2940_reg1) table_reduce_table_2940_upd1 = {
    void apply(inout bit<32> val, out bit<32> res) {
      res = val;
      val = val + 1;
    }
  };
  RegisterAction<bit<32>, bit<32>, bit<32>>(table_reduce_table_2940_reg1) table_reduce_table_2940_get1 = {
    void apply(inout bit<32> val, out bit<32> res) {
      res = val;
    }
  };
  // generated by _CountMinSketch_140480949613568 end
  // generated by _TableFactory140480949613040 end

  apply {
    tab_forward.apply();
    // generated by _StatementFactory140480949616496 start
    var_task_mask = 0;
    if (hdr.ipv4.protocol == IP_PROTOCOLS_TCP) {
      if (hdr.tcp.flags == TCP_FLAG_SYN) {
        var_task_mask = var_task_mask | 1;
      }
    }
    
    if ((var_task_mask & 32w1) != 0) {
      var_index_2880 = hdr.ipv4.dst_addr;
      table_reduce_table_2940_index = table_reduce_table_2940_hash0.get({hdr.ipv4.dst_addr});
      table_reduce_table_2940_index = table_reduce_table_2940_index % 16384;
      table_reduce_table_2940_upd0.execute(table_reduce_table_2940_index);
      table_reduce_table_2940_index = table_reduce_table_2940_hash1.get({hdr.ipv4.dst_addr});
      table_reduce_table_2940_index = table_reduce_table_2940_index % 16384;
      table_reduce_table_2940_upd1.execute(table_reduce_table_2940_index);
      table_reduce_table_2940_index = table_reduce_table_2940_hash0.get({hdr.ipv4.dst_addr});
      table_reduce_table_2940_index = table_reduce_table_2940_index % 16384;
      table_reduce_table_2940_value = table_reduce_table_2940_get0.execute(table_reduce_table_2940_index);
      var_count_29d0 = table_reduce_table_2940_value;
      table_reduce_table_2940_index = table_reduce_table_2940_hash1.get({hdr.ipv4.dst_addr});
      table_reduce_table_2940_index = table_reduce_table_2940_index % 16384;
      table_reduce_table_2940_value = table_reduce_table_2940_get1.execute(table_reduce_table_2940_index);
      var_count_29d0 = min(var_count_29d0, table_reduce_table_2940_value);
      if (var_count_29d0 == const_50_2ac0) {
        ig_tm_md.ucast_egress_port = UNUSUAL_EGRESS_PORT;
      }
    }
    // generated by _StatementFactory140480949616496 end
  }
  // generated by SwitchEgressFactory140480949616112 end

}

control SwitchIngressDeparser(
    packet_out pkt,
    inout my_hdr_t hdr,
    in ig_md_t ig_md,
    in ingress_intrinsic_metadata_for_deparser_t ig_dprsr_md) {

  apply {
    pkt.emit(hdr);
  }
}

parser SwitchEgressParser(
    packet_in pkt,
    out my_hdr_t hdr,
    out eg_md_t eg_md,
    out egress_intrinsic_metadata_t eg_intr_md) {

  TofinoEgressParser() tofino_parser;

  state start {
    tofino_parser.apply(pkt, eg_intr_md);
    transition parse_ethernet;
  }

  state parse_ethernet {
    pkt.extract(hdr.ethernet);
    transition select (hdr.ethernet.ether_type) {
      ETHERTYPE_IPV4: parse_ipv4;
      default:        accept;
    }
  }

  state parse_ipv4 {
    pkt.extract(hdr.ipv4);

    transition select (hdr.ipv4.ihl, hdr.ipv4.protocol) {
      (5, IP_PROTOCOLS_UDP): parse_udp;
      (5, IP_PROTOCOLS_TCP): parse_tcp;
      default:               accept;
    }
  }

  state parse_udp {
    pkt.extract(hdr.udp);
    transition accept;
  }

  state parse_tcp {
    pkt.extract(hdr.tcp);
    transition accept;
  }
}


control SwitchEgress(
    inout my_hdr_t hdr,
    inout eg_md_t eg_md,
    in egress_intrinsic_metadata_t                 eg_intr_md,
    in egress_intrinsic_metadata_from_parser_t     eg_prsr_md,
    inout egress_intrinsic_metadata_for_deparser_t    eg_dprsr_md,
    inout egress_intrinsic_metadata_for_output_port_t eg_oport_md) {

  apply {
  }
}

control SwitchEgressDeparser(
    packet_out pkt,
    inout my_hdr_t hdr,
    in eg_md_t eg_md,
    in egress_intrinsic_metadata_for_deparser_t eg_dprsr_md) {

  apply {
    pkt.emit(hdr);
  }
}

Pipeline(SwitchIngressParser(),
         SwitchIngress(),
         SwitchIngressDeparser(),
         SwitchEgressParser(),
         SwitchEgress(),
         SwitchEgressDeparser()) pipe;

Switch(pipe) main;
