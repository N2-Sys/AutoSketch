#include <core.p4>
#include <tna.p4>

#include "../common/headers.p4"
#include "../common/util.p4"

struct my_hdr_t {
  ethernet_h ethernet;
  ipv4_h     ipv4;
  udp_h      udp;
  tcp_h      tcp;
}

header eg_mirror_h {
}

struct ig_md_t {
  bit<32> fingerprint;
}

struct eg_md_t {
}

// generated by StructDefinitionFactory_139820586958272 start
// generated by StructDefinitionFactory_139820586958272 end


parser SwitchIngressParser(
    packet_in pkt,
    out my_hdr_t hdr,
    out ig_md_t ig_md,
    out ingress_intrinsic_metadata_t ig_intr_md
  ) {

  TofinoIngressParser() tofino_parser;

  state start {
    tofino_parser.apply(pkt, ig_intr_md);
    transition parse_ethernet;
  }

  state parse_ethernet {
    pkt.extract(hdr.ethernet);
    transition select (hdr.ethernet.ether_type) {
      ETHERTYPE_IPV4: parse_ipv4;
      default:        accept;
    }
  }

  state parse_ipv4 {
    pkt.extract(hdr.ipv4);
    transition select (hdr.ipv4.ihl, hdr.ipv4.protocol) {
      (5, IP_PROTOCOLS_UDP): parse_udp;
      (5, IP_PROTOCOLS_TCP): parse_tcp;
      default:               accept;
    }
  }

  state parse_udp {
    pkt.extract(hdr.udp);
    transition accept;
  }

  state parse_tcp {
    pkt.extract(hdr.tcp);
    transition accept;
  }
}

control SwitchIngress(
    inout my_hdr_t hdr,
    inout ig_md_t ig_md,
    in ingress_intrinsic_metadata_t ig_intr_md,
    in ingress_intrinsic_metadata_from_parser_t ig_prsr_md,
    inout ingress_intrinsic_metadata_for_deparser_t ig_dprsr_md,
    inout ingress_intrinsic_metadata_for_tm_t ig_tm_md) {

  action send(PortId_t egress_port) {
    ig_tm_md.ucast_egress_port = egress_port;
  }

  action drop() {
    ig_dprsr_md.drop_ctl = 0x1;
  }

  table tab_forward {
    key = {
      ig_intr_md.ingress_port : exact;
    }

    actions = {
      send;
      @defaultonly drop;
    }

    const default_action = drop();
    size = 512;
  }

  // generated by SwitchEgressFactory139820586957648 start
  // generated by _ValueFactory139820586957888 start
  bit<32> var_task_mask;
  bit<32> var_index_cb80;
  bit<1> var_distinct_query_cca0;
  bit<32> var_index_cf70;
  bit<32> var_count_f100;
  const bit<32> const_count_cee0 = 32w1;
  const bit<32> const_200_f1f0 = 32w200;
  const bit<32> const_UNUSUAL_EGRESS_PORT_f310 = UNUSUAL_EGRESS_PORT;
  Hash<bit<32>>(HashAlgorithm_t.CRC32) var_index_cb80_crc32;
  // generated by _ValueFactory139820586957888 end

  // generated by _TableFactory139820586957072 start
  // generated by _BloomFilter_139820586956112 start
  bit<32> table_distinct_table_cc40_index;
  bit<1> table_distinct_table_cc40_value;
  CRCPolynomial<bit<32>>(0x4a44, true, false, false, 0, 0) table_distinct_table_cc40_poly0;
  Hash<bit<32>>(HashAlgorithm_t.CRC32, table_distinct_table_cc40_poly0) table_distinct_table_cc40_hash0;
  Register<bit<1>, bit<32>>(524288, 0) table_distinct_table_cc40_reg0;
  RegisterAction<bit<1>, bit<32>, bit<1>>(table_distinct_table_cc40_reg0) table_distinct_table_cc40_upd0 = {
    void apply(inout bit<1> val, out bit<1> res) {
      res = val;
      val = 1;
    }
  };
  RegisterAction<bit<1>, bit<32>, bit<1>>(table_distinct_table_cc40_reg0) table_distinct_table_cc40_get0 = {
    void apply(inout bit<1> val, out bit<1> res) {
      res = val;
    }
  };
  CRCPolynomial<bit<32>>(0x1a4f, true, false, false, 0, 0) table_distinct_table_cc40_poly1;
  Hash<bit<32>>(HashAlgorithm_t.CRC32, table_distinct_table_cc40_poly1) table_distinct_table_cc40_hash1;
  Register<bit<1>, bit<32>>(524288, 0) table_distinct_table_cc40_reg1;
  RegisterAction<bit<1>, bit<32>, bit<1>>(table_distinct_table_cc40_reg1) table_distinct_table_cc40_upd1 = {
    void apply(inout bit<1> val, out bit<1> res) {
      res = val;
      val = 1;
    }
  };
  RegisterAction<bit<1>, bit<32>, bit<1>>(table_distinct_table_cc40_reg1) table_distinct_table_cc40_get1 = {
    void apply(inout bit<1> val, out bit<1> res) {
      res = val;
    }
  };
  CRCPolynomial<bit<32>>(0xc7fb, true, false, false, 0, 0) table_distinct_table_cc40_poly2;
  Hash<bit<32>>(HashAlgorithm_t.CRC32, table_distinct_table_cc40_poly2) table_distinct_table_cc40_hash2;
  Register<bit<1>, bit<32>>(524288, 0) table_distinct_table_cc40_reg2;
  RegisterAction<bit<1>, bit<32>, bit<1>>(table_distinct_table_cc40_reg2) table_distinct_table_cc40_upd2 = {
    void apply(inout bit<1> val, out bit<1> res) {
      res = val;
      val = 1;
    }
  };
  RegisterAction<bit<1>, bit<32>, bit<1>>(table_distinct_table_cc40_reg2) table_distinct_table_cc40_get2 = {
    void apply(inout bit<1> val, out bit<1> res) {
      res = val;
    }
  };
  // generated by _BloomFilter_139820586956112 end
  // generated by _CountMinSketch_139820586958560 start
  bit<32> table_reduce_table_f070_index;
  bit<32> table_reduce_table_f070_value;
  CRCPolynomial<bit<32>>(0x80, true, false, false, 0, 0) table_reduce_table_f070_poly0;
  Hash<bit<32>>(HashAlgorithm_t.CRC32, table_reduce_table_f070_poly0) table_reduce_table_f070_hash0;
  Register<bit<32>, bit<32>>(65536, 0) table_reduce_table_f070_reg0;
  RegisterAction<bit<32>, bit<32>, bit<32>>(table_reduce_table_f070_reg0) table_reduce_table_f070_upd0 = {
    void apply(inout bit<32> val, out bit<32> res) {
      res = val;
      val = val + 1;
    }
  };
  RegisterAction<bit<32>, bit<32>, bit<32>>(table_reduce_table_f070_reg0) table_reduce_table_f070_get0 = {
    void apply(inout bit<32> val, out bit<32> res) {
      res = val;
    }
  };
  // generated by _CountMinSketch_139820586958560 end
  // generated by _TableFactory139820586957072 end

  apply {
    tab_forward.apply();
    // generated by _StatementFactory139820586956160 start
    var_task_mask = 0;
    var_task_mask = var_task_mask | 1;
    
    if ((var_task_mask & 32w1) != 0) {
      var_index_cb80 = var_index_cb80_crc32.get({hdr.ipv4.dst_addr, hdr.ipv4.src_addr});
      table_distinct_table_cc40_index = table_distinct_table_cc40_hash0.get({hdr.ipv4.dst_addr, hdr.ipv4.src_addr});
      table_distinct_table_cc40_index = table_distinct_table_cc40_index % 524288;
      table_distinct_table_cc40_value = table_distinct_table_cc40_upd0.execute(table_distinct_table_cc40_index);
      var_distinct_query_cca0 = table_distinct_table_cc40_value;
      table_distinct_table_cc40_index = table_distinct_table_cc40_hash1.get({hdr.ipv4.dst_addr, hdr.ipv4.src_addr});
      table_distinct_table_cc40_index = table_distinct_table_cc40_index % 524288;
      table_distinct_table_cc40_value = table_distinct_table_cc40_upd1.execute(table_distinct_table_cc40_index);
      var_distinct_query_cca0 = var_distinct_query_cca0 & table_distinct_table_cc40_value;
      table_distinct_table_cc40_index = table_distinct_table_cc40_hash2.get({hdr.ipv4.dst_addr, hdr.ipv4.src_addr});
      table_distinct_table_cc40_index = table_distinct_table_cc40_index % 524288;
      table_distinct_table_cc40_value = table_distinct_table_cc40_upd2.execute(table_distinct_table_cc40_index);
      var_distinct_query_cca0 = var_distinct_query_cca0 & table_distinct_table_cc40_value;
      if (var_distinct_query_cca0 == 1w0) {
        var_index_cf70 = hdr.ipv4.src_addr;
        table_reduce_table_f070_index = table_reduce_table_f070_hash0.get({hdr.ipv4.src_addr});
        table_reduce_table_f070_index = table_reduce_table_f070_index % 65536;
        table_reduce_table_f070_upd0.execute(table_reduce_table_f070_index);
        table_reduce_table_f070_index = table_reduce_table_f070_hash0.get({hdr.ipv4.src_addr});
        table_reduce_table_f070_index = table_reduce_table_f070_index % 65536;
        table_reduce_table_f070_value = table_reduce_table_f070_get0.execute(table_reduce_table_f070_index);
        var_count_f100 = table_reduce_table_f070_value;
        if (var_count_f100 == const_200_f1f0) {
          ig_tm_md.ucast_egress_port = UNUSUAL_EGRESS_PORT;
        }
      }
    }
    // generated by _StatementFactory139820586956160 end
  }
  // generated by SwitchEgressFactory139820586957648 end

}

control SwitchIngressDeparser(
    packet_out pkt,
    inout my_hdr_t hdr,
    in ig_md_t ig_md,
    in ingress_intrinsic_metadata_for_deparser_t ig_dprsr_md) {

  apply {
    pkt.emit(hdr);
  }
}

parser SwitchEgressParser(
    packet_in pkt,
    out my_hdr_t hdr,
    out eg_md_t eg_md,
    out egress_intrinsic_metadata_t eg_intr_md) {

  TofinoEgressParser() tofino_parser;

  state start {
    tofino_parser.apply(pkt, eg_intr_md);
    transition parse_ethernet;
  }

  state parse_ethernet {
    pkt.extract(hdr.ethernet);
    transition select (hdr.ethernet.ether_type) {
      ETHERTYPE_IPV4: parse_ipv4;
      default:        accept;
    }
  }

  state parse_ipv4 {
    pkt.extract(hdr.ipv4);

    transition select (hdr.ipv4.ihl, hdr.ipv4.protocol) {
      (5, IP_PROTOCOLS_UDP): parse_udp;
      (5, IP_PROTOCOLS_TCP): parse_tcp;
      default:               accept;
    }
  }

  state parse_udp {
    pkt.extract(hdr.udp);
    transition accept;
  }

  state parse_tcp {
    pkt.extract(hdr.tcp);
    transition accept;
  }
}


control SwitchEgress(
    inout my_hdr_t hdr,
    inout eg_md_t eg_md,
    in egress_intrinsic_metadata_t                 eg_intr_md,
    in egress_intrinsic_metadata_from_parser_t     eg_prsr_md,
    inout egress_intrinsic_metadata_for_deparser_t    eg_dprsr_md,
    inout egress_intrinsic_metadata_for_output_port_t eg_oport_md) {

  apply {
  }
}

control SwitchEgressDeparser(
    packet_out pkt,
    inout my_hdr_t hdr,
    in eg_md_t eg_md,
    in egress_intrinsic_metadata_for_deparser_t eg_dprsr_md) {

  apply {
    pkt.emit(hdr);
  }
}

Pipeline(SwitchIngressParser(),
         SwitchIngress(),
         SwitchIngressDeparser(),
         SwitchEgressParser(),
         SwitchEgress(),
         SwitchEgressDeparser()) pipe;

Switch(pipe) main;
