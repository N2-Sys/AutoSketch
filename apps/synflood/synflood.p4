#include <core.p4>
#include <tna.p4>

#include "../common/headers.p4"
#include "../common/util.p4"

struct my_hdr_t {
  ethernet_h ethernet;
  ipv4_h     ipv4;
  udp_h      udp;
  tcp_h      tcp;
}

header eg_mirror_h {
}

struct ig_md_t {
  bit<32> fingerprint;
}

struct eg_md_t {
}

// generated by StructDefinitionFactory_140295951600272 start
struct sf_seq_t {
  bit<32> nextseq;
}

struct sf_cnt_t {
  bit<32> cnt;
}

// generated by StructDefinitionFactory_140295951600272 end


parser SwitchIngressParser(
    packet_in pkt,
    out my_hdr_t hdr,
    out ig_md_t ig_md,
    out ingress_intrinsic_metadata_t ig_intr_md
  ) {

  TofinoIngressParser() tofino_parser;

  state start {
    tofino_parser.apply(pkt, ig_intr_md);
    transition parse_ethernet;
  }

  state parse_ethernet {
    pkt.extract(hdr.ethernet);
    transition select (hdr.ethernet.ether_type) {
      ETHERTYPE_IPV4: parse_ipv4;
      default:        accept;
    }
  }

  state parse_ipv4 {
    pkt.extract(hdr.ipv4);
    transition select (hdr.ipv4.ihl, hdr.ipv4.protocol) {
      (5, IP_PROTOCOLS_UDP): parse_udp;
      (5, IP_PROTOCOLS_TCP): parse_tcp;
      default:               accept;
    }
  }

  state parse_udp {
    pkt.extract(hdr.udp);
    transition accept;
  }

  state parse_tcp {
    pkt.extract(hdr.tcp);
    transition accept;
  }
}

control SwitchIngress(
    inout my_hdr_t hdr,
    inout ig_md_t ig_md,
    in ingress_intrinsic_metadata_t ig_intr_md,
    in ingress_intrinsic_metadata_from_parser_t ig_prsr_md,
    inout ingress_intrinsic_metadata_for_deparser_t ig_dprsr_md,
    inout ingress_intrinsic_metadata_for_tm_t ig_tm_md) {

  action send(PortId_t egress_port) {
    ig_tm_md.ucast_egress_port = egress_port;
  }

  action drop() {
    ig_dprsr_md.drop_ctl = 0x1;
  }

  table tab_forward {
    key = {
      ig_intr_md.ingress_port : exact;
    }

    actions = {
      send;
      @defaultonly drop;
    }

    const default_action = drop();
    size = 512;
  }

  // generated by SwitchEgressFactory140295951599456 start
  // generated by _ValueFactory140295951600800 start
  bit<32> var_task_mask;
  bit<32> var_nkey_6250;
  bit<32> var_cnt_flag_6940;
  bit<32> var_index_c580;
  bit<32> var_nextseq_c6d0;
  bit<32> var_tmp_c8e0;
  bit<32> var_cnt_cfa0;
  const bit<32> const_TCP_FLAG_SYN_ACK_6c70 = TCP_FLAG_SYN_ACK;
  const bit<32> const_12_e550 = 32w12;
  const bit<32> const_UNUSUAL_EGRESS_PORT_e670 = UNUSUAL_EGRESS_PORT;
  // generated by _ValueFactory140295951600800 end

  // generated by _TableFactory140295951600224 start
  // generated by UDFTable_140295951606832 start
  bit<32> sf_seq_index;
  bit<1> sf_seq_fp_hit;
  CRCPolynomial<bit<32>>(0x2df, true, false, false, 0, 0) sf_seq_poly0;
  Hash<bit<32>>(HashAlgorithm_t.CRC32, sf_seq_poly0) sf_seq_hash0;
  Register<bit<32>, bit<32>>(4096, 0) sf_seq_fingerprint0;
  RegisterAction<bit<32>, bit<32>, bit<1>>(sf_seq_fingerprint0) sf_seq_fingerprint_action0 = {
    void apply(inout bit<32> fp, out bit<1> hit_flag) {
      if (fp == 0 || fp == ig_md.fingerprint) {
        hit_flag = 1;
        fp = ig_md.fingerprint;
      } else {
        hit_flag = 0;
      }
    }
  };
  Register<sf_seq_t, bit<32>>(4096) sf_seq_reg0;
  RegisterAction<sf_seq_t, bit<32>, bit<32>>(sf_seq_reg0) sf_seq_action0 = {
    void apply(inout sf_seq_t val, out bit<32> res) {
      bit<32> tmp;
      bit<32> nextseq;
      if (hdr.tcp.flags == const_TCP_FLAG_SYN_ACK_6c70) {
        tmp = hdr.tcp.seq + 32w1;
        val.nextseq = tmp;
      }
      nextseq = val.nextseq;
      res = nextseq;
    }
  };
  // generated by UDFTable_140295951606832 end
  // generated by UDFTable_140295951608464 start
  bit<32> sf_cnt_index;
  bit<1> sf_cnt_fp_hit;
  CRCPolynomial<bit<32>>(0xb7bf, true, false, false, 0, 0) sf_cnt_poly0;
  Hash<bit<32>>(HashAlgorithm_t.CRC32, sf_cnt_poly0) sf_cnt_hash0;
  Register<bit<32>, bit<32>>(4096, 0) sf_cnt_fingerprint0;
  RegisterAction<bit<32>, bit<32>, bit<1>>(sf_cnt_fingerprint0) sf_cnt_fingerprint_action0 = {
    void apply(inout bit<32> fp, out bit<1> hit_flag) {
      if (fp == 0 || fp == ig_md.fingerprint) {
        hit_flag = 1;
        fp = ig_md.fingerprint;
      } else {
        hit_flag = 0;
      }
    }
  };
  Register<sf_cnt_t, bit<32>>(4096) sf_cnt_reg0;
  RegisterAction<sf_cnt_t, bit<32>, bit<32>>(sf_cnt_reg0) sf_cnt_action0 = {
    void apply(inout sf_cnt_t val, out bit<32> res) {
      bit<32> cnt;
      if (var_cnt_flag_6940 == 32w1) {
        val.cnt = val.cnt + 32w1;
      } else {
        if (var_cnt_flag_6940 == 32w2) {
          val.cnt = val.cnt - 32w1;
        }
      }
      cnt = val.cnt;
      res = cnt;
    }
  };
  CRCPolynomial<bit<32>>(0x6a40, true, false, false, 0, 0) sf_cnt_poly1;
  Hash<bit<32>>(HashAlgorithm_t.CRC32, sf_cnt_poly1) sf_cnt_hash1;
  Register<bit<32>, bit<32>>(4096, 0) sf_cnt_fingerprint1;
  RegisterAction<bit<32>, bit<32>, bit<1>>(sf_cnt_fingerprint1) sf_cnt_fingerprint_action1 = {
    void apply(inout bit<32> fp, out bit<1> hit_flag) {
      if (fp == 0 || fp == ig_md.fingerprint) {
        hit_flag = 1;
        fp = ig_md.fingerprint;
      } else {
        hit_flag = 0;
      }
    }
  };
  Register<sf_cnt_t, bit<32>>(4096) sf_cnt_reg1;
  RegisterAction<sf_cnt_t, bit<32>, bit<32>>(sf_cnt_reg1) sf_cnt_action1 = {
    void apply(inout sf_cnt_t val, out bit<32> res) {
      bit<32> cnt;
      if (var_cnt_flag_6940 == 32w1) {
        val.cnt = val.cnt + 32w1;
      } else {
        if (var_cnt_flag_6940 == 32w2) {
          val.cnt = val.cnt - 32w1;
        }
      }
      cnt = val.cnt;
      res = cnt;
    }
  };
  // generated by UDFTable_140295951608464 end
  // generated by _TableFactory140295951600224 end

  apply {
    tab_forward.apply();
    // generated by _StatementFactory140295951598544 start
    var_task_mask = 0;
    if (hdr.ipv4.protocol == IP_PROTOCOLS_TCP) {
      if ((hdr.tcp.flags & TCP_FLAG_ACK) != 0) {
        var_task_mask = var_task_mask | 1;
      }
    }
    
    if ((var_task_mask & 32w1) != 0) {
      if (hdr.tcp.flags == const_TCP_FLAG_SYN_ACK_6c70) {
        var_nkey_6250 = hdr.ipv4.src_addr;
        var_cnt_flag_6940 = 32w1;
      } else {
        var_nkey_6250 = hdr.ipv4.dst_addr;
        var_cnt_flag_6940 = 32w0;
      }
      var_index_c580 = var_nkey_6250;
      ig_md.fingerprint = var_index_c580;
      sf_seq_index = sf_seq_hash0.get({var_nkey_6250});
      sf_seq_index = sf_seq_index % 4096;
      sf_seq_fp_hit = sf_seq_fingerprint_action0.execute(sf_seq_index);
      if (sf_seq_fp_hit == 1) {
        var_nextseq_c6d0 = sf_seq_action0.execute(sf_seq_index);
      }
      if (var_nextseq_c6d0 == hdr.tcp.ack) {
        var_cnt_flag_6940 = 32w2;
      }
      ig_md.fingerprint = var_index_c580;
      sf_cnt_index = sf_cnt_hash0.get({var_nkey_6250});
      sf_cnt_index = sf_cnt_index % 4096;
      sf_cnt_fp_hit = sf_cnt_fingerprint_action0.execute(sf_cnt_index);
      if (sf_cnt_fp_hit == 1) {
        var_cnt_cfa0 = sf_cnt_action0.execute(sf_cnt_index);
      } else {
        sf_cnt_index = sf_cnt_hash1.get({var_nkey_6250});
        sf_cnt_index = sf_cnt_index % 4096;
        sf_cnt_fp_hit = sf_cnt_fingerprint_action1.execute(sf_cnt_index);
        if (sf_cnt_fp_hit == 1) {
          var_cnt_cfa0 = sf_cnt_action1.execute(sf_cnt_index);
        }
      }
      if (var_cnt_cfa0 == const_12_e550) {
        ig_tm_md.ucast_egress_port = UNUSUAL_EGRESS_PORT;
      }
    }
    // generated by _StatementFactory140295951598544 end
  }
  // generated by SwitchEgressFactory140295951599456 end

}

control SwitchIngressDeparser(
    packet_out pkt,
    inout my_hdr_t hdr,
    in ig_md_t ig_md,
    in ingress_intrinsic_metadata_for_deparser_t ig_dprsr_md) {

  apply {
    pkt.emit(hdr);
  }
}

parser SwitchEgressParser(
    packet_in pkt,
    out my_hdr_t hdr,
    out eg_md_t eg_md,
    out egress_intrinsic_metadata_t eg_intr_md) {

  TofinoEgressParser() tofino_parser;

  state start {
    tofino_parser.apply(pkt, eg_intr_md);
    transition parse_ethernet;
  }

  state parse_ethernet {
    pkt.extract(hdr.ethernet);
    transition select (hdr.ethernet.ether_type) {
      ETHERTYPE_IPV4: parse_ipv4;
      default:        accept;
    }
  }

  state parse_ipv4 {
    pkt.extract(hdr.ipv4);

    transition select (hdr.ipv4.ihl, hdr.ipv4.protocol) {
      (5, IP_PROTOCOLS_UDP): parse_udp;
      (5, IP_PROTOCOLS_TCP): parse_tcp;
      default:               accept;
    }
  }

  state parse_udp {
    pkt.extract(hdr.udp);
    transition accept;
  }

  state parse_tcp {
    pkt.extract(hdr.tcp);
    transition accept;
  }
}


control SwitchEgress(
    inout my_hdr_t hdr,
    inout eg_md_t eg_md,
    in egress_intrinsic_metadata_t                 eg_intr_md,
    in egress_intrinsic_metadata_from_parser_t     eg_prsr_md,
    inout egress_intrinsic_metadata_for_deparser_t    eg_dprsr_md,
    inout egress_intrinsic_metadata_for_output_port_t eg_oport_md) {

  apply {
  }
}

control SwitchEgressDeparser(
    packet_out pkt,
    inout my_hdr_t hdr,
    in eg_md_t eg_md,
    in egress_intrinsic_metadata_for_deparser_t eg_dprsr_md) {

  apply {
    pkt.emit(hdr);
  }
}

Pipeline(SwitchIngressParser(),
         SwitchIngress(),
         SwitchIngressDeparser(),
         SwitchEgressParser(),
         SwitchEgress(),
         SwitchEgressDeparser()) pipe;

Switch(pipe) main;
