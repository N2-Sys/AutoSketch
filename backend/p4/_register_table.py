from ir import resona
from random import randint
from backend.p4._template import unit_indent
from typing import List

class RegisterTableBase:
    def __init__(self, resona_table : resona.RegisterTable):
        pass

    def set_table_size(self, table_size : int):
        pass

    def set_table_depth(self, table_depth : int):
        pass

    def get_elem_width(self):
        pass

    def update(self, key : str, op : str, value : str, hash_key : str, res) -> List[str]:
        pass

    def query(self, key : str, res : str, hash_key : str) -> List[str]:
        pass

    def dump(self) -> List[str]:
        return []

class ReduceTableBase(RegisterTableBase):
    pass

class AssignTableBase(RegisterTableBase):
    pass

class UDFTable:
    def __init__(self, name : str, table_size : int, table_depth : int):
        self.name = name
        self.table_size = table_size
        self.index_width = 32
        self.n_tables = table_depth
        self.register_action = []
        self.output_width = 32
    
    def action(self, out, hash_key) -> List[str]:
        output = []
        for i in range(self.n_tables):
            output.append(unit_indent * i + f"{self.name}_index = {self.name}_hash{i}.get({hash_key});")
            output.append(unit_indent * i + f"{self.name}_index = {self.name}_index % {self.table_size};")
            output.append(unit_indent * i + f"{self.name}_fp_hit = {self.name}_fingerprint_action{i}.execute({self.name}_index);")
            output.append(unit_indent * i + f"if ({self.name}_fp_hit == 1) " + '{')
            if out == None:
                output.append(unit_indent * (i + 1) + f"{self.name}_action{i}.execute({self.name}_index);")
            else:
                output.append(unit_indent * (i + 1) + f"{out} = {self.name}_action{i}.execute({self.name}_index);")
            output.append(unit_indent * i + "} else {")
        output.pop(-1)
        for i in range(self.n_tables):
            output.append(unit_indent * (self.n_tables - i - 1) + "}")
        return output

    def dump(self) -> List[str]:
        output = []
        output.append(f"// generated by UDFTable_{id(self)} start")
        output.append(f"bit<{self.index_width}> {self.name}_index;")
        output.append(f"bit<1> {self.name}_fp_hit;")
        for i in range(self.n_tables):
            output.append(f"CRCPolynomial<bit<{self.index_width}>>({hex(randint(0, 0xFFFF))}, true, false, false, 0, 0) {self.name}_poly{i};")
            output.append(f"Hash<bit<{self.index_width}>>(HashAlgorithm_t.CRC{self.index_width}, {self.name}_poly{i}) {self.name}_hash{i};")
            output.append(f"Register<bit<32>, bit<{self.index_width}>>({self.table_size}, 0) {self.name}_fingerprint{i};")
            output.append(f"RegisterAction<bit<32>, bit<{self.index_width}>, bit<1>>({self.name}_fingerprint{i}) {self.name}_fingerprint_action{i} = {'{'}")
            output.append(unit_indent + f"void apply(inout bit<32> fp, out bit<1> hit_flag) {'{'}")
            output.append(unit_indent + unit_indent + f"if (fp == 0 || fp == ig_md.fingerprint) " + '{')
            output.append(unit_indent + unit_indent + unit_indent + "hit_flag = 1;")
            output.append(unit_indent + unit_indent + unit_indent + "fp = ig_md.fingerprint;")
            output.append(unit_indent + unit_indent + "} else {")
            output.append(unit_indent + unit_indent + unit_indent + "hit_flag = 0;")
            output.append(unit_indent + unit_indent + "}")
            output.append(unit_indent + "}")
            output.append("};")
            output.append(f"Register<{self.name}_t, bit<{self.index_width}>>({self.table_size}) {self.name}_reg{i};")
            output.append(f"RegisterAction<{self.name}_t, bit<{self.index_width}>, bit<{self.output_width}>>({self.name}_reg{i}) {self.name}_action{i} = {'{'}")
            output.append(unit_indent + f"void apply(inout {self.name}_t val, out bit<{self.output_width}> res) {'{'}")
            output += [unit_indent + unit_indent + line for line in self.register_action]
            output.append(unit_indent + "}")
            output.append("};")
        output.append(f"// generated by UDFTable_{id(self)} end")
        return output

class _CountMinSketch_impl:
    def __init__(self, id, elem_width, table_size, index_width, n_tables):
        self.id = id
        self.elem_width = elem_width
        self.table_size = table_size
        self.index_width = index_width
        self.n_tables = n_tables
        # {self.id}_xxx{i}

    def update(self, key : str, hash_key : str, res) -> List[str]:
        assert res == None
        output = []
        if hash_key == "":
            hash_key = key
        for i in range(self.n_tables):
            output.append(f"{self.id}_index = {self.id}_hash{i}.get({hash_key});")
            output.append(f"{self.id}_index = {self.id}_index % {self.table_size};")
            output.append(f"{self.id}_upd{i}.execute({self.id}_index);")
        return output

    def query(self, key : str, res : str, hash_key : str) -> List[str]:
        output = []
        if hash_key == "":
            hash_key = key
        output.append(f"{self.id}_index = {self.id}_hash0.get({hash_key});")
        output.append(f"{self.id}_index = {self.id}_index % {self.table_size};")
        output.append(f"{self.id}_value = {self.id}_get0.execute({self.id}_index);")
        output.append(f"{res} = {self.id}_value;")
        for i in range(1, self.n_tables):
            output.append(f"{self.id}_index = {self.id}_hash{i}.get({hash_key});")
            output.append(f"{self.id}_index = {self.id}_index % {self.table_size};")
            output.append(f"{self.id}_value = {self.id}_get{i}.execute({self.id}_index);")
            output.append(f"{res} = min({res}, {self.id}_value);")
        return output

    def dump(self) -> List[str]:
        output = []
        output.append(f"bit<{self.index_width}> {self.id}_index;")
        output.append(f"bit<{self.elem_width}> {self.id}_value;")
        for i in range(self.n_tables):
            output.append(f"CRCPolynomial<bit<{self.index_width}>>({hex(randint(0, 0xFFFF))}, true, false, false, 0, 0) {self.id}_poly{i};")
            output.append(f"Hash<bit<{self.index_width}>>(HashAlgorithm_t.CRC{self.index_width}, {self.id}_poly{i}) {self.id}_hash{i};")
            output.append(f"Register<bit<{self.elem_width}>, bit<{self.index_width}>>({self.table_size}, 0) {self.id}_reg{i};")
            # upd
            output.append(f"RegisterAction<bit<{self.elem_width}>, bit<{self.index_width}>, bit<{self.elem_width}>>({self.id}_reg{i}) {self.id}_upd{i} = {'{'}")
            output.append(unit_indent + f"void apply(inout bit<{self.elem_width}> val, out bit<{self.elem_width}> res) {'{'}")
            output.append(unit_indent + unit_indent + "res = val;")
            output.append(unit_indent + unit_indent + "val = val + 1;")
            output.append(unit_indent + "}")
            output.append("};")
            # reset
            # output.append(f"RegisterAction<bit<{self.elem_width}>, bit<{self.index_width}>, void>({self.id}_reg{i}) {self.id}_reset{i} = {'{'}")
            # output.append(unit_indent + f"void apply(inout bit<{self.elem_width}> val) {'{'}")
            # output.append(unit_indent + unit_indent + "val = 0;")
            # output.append(unit_indent + "}")
            # output.append("};")
            # get
            output.append(f"RegisterAction<bit<{self.elem_width}>, bit<{self.index_width}>, bit<{self.elem_width}>>({self.id}_reg{i}) {self.id}_get{i} = {'{'}")
            output.append(unit_indent + f"void apply(inout bit<{self.elem_width}> val, out bit<{self.elem_width}> res) {'{'}")
            output.append(unit_indent + unit_indent + "res = val;")
            output.append(unit_indent + "}")
            output.append("};")
        return output

class _CountMinSketch(ReduceTableBase):
    def __init__(self, resona_table : resona.RegisterTable):
        self._cm_impl = _CountMinSketch_impl(
            id = resona_table.get_id(),
            elem_width = resona_table.value_width,
            table_size = 1 << 16,
            index_width = 32,
            n_tables = 2,
        )

    def set_table_size(self, table_size : int):
        self._cm_impl.table_size = table_size

    def set_table_depth(self, table_depth : int):
        self._cm_impl.n_tables = table_depth
    
    def get_elem_width(self):
        return self._cm_impl.elem_width
    
    def update(self, key : str, op : str, value : str, hash_key : str, res) -> List[str]:
        assert op == 'add'
        # TODO: assert value == 1
        return self._cm_impl.update(key, hash_key, res)

    def query(self, key : str, res : str, hash_key : str) -> List[str]:
        return self._cm_impl.query(key, res, hash_key)

    def dump(self) -> List[str]:
        output = []
        output.append(f"// generated by _CountMinSketch_{id(self)} start")
        output += self._cm_impl.dump()
        output.append(f"// generated by _CountMinSketch_{id(self)} end")
        return output

class _CountSketch(ReduceTableBase):
    pass

class _BloomFilter(AssignTableBase):
    def __init__(self, resona_table : resona.RegisterTable):
        self.id = resona_table.get_id()
        self.elem_width = resona_table.value_width
        self.table_size = 1 << 16
        self.index_width = 32
        self.n_tables = 2
        # {self.id}_xxx{i}
    
    def set_table_size(self, table_size : int):
        self.table_size = table_size

    def set_table_depth(self, table_depth : int):
        self.n_tables = table_depth
    
    def get_elem_width(self):
        return self.elem_width

    def update(self, key : str, op : str, value : str, hash_key : str, res) -> List[str]:
        assert op == 'assign'
        # TODO: assert value == 1
        output = []
        if hash_key == "":
            hash_key = key
        for i in range(self.n_tables):
            output.append(f"{self.id}_index = {self.id}_hash{i}.get({hash_key});")
            output.append(f"{self.id}_index = {self.id}_index % {self.table_size};")
            output.append(f"{self.id}_value = {self.id}_upd{i}.execute({self.id}_index);")
            if res != None:
                if i == 0:
                    output.append(f"{res} = {self.id}_value;")
                else:
                    output.append(f"{res} = {res} & {self.id}_value;")
        return output

    def query(self, key : str, res : str, hash_key : str) -> List[str]:
        output = []
        if hash_key == "":
            hash_key = key
        output.append(f"{self.id}_index = {self.id}_hash0.get({hash_key});")
        output.append(f"{self.id}_index = {self.id}_index % {self.table_size};")
        output.append(f"{self.id}_value = {self.id}_get0.execute({self.id}_index);")
        output.append(f"{res} = {self.id}_value;")
        for i in range(1, self.n_tables):
            output.append(f"{self.id}_index = {self.id}_hash{i}.get({hash_key});")
            output.append(f"{self.id}_index = {self.id}_index % {self.table_size};")
            output.append(f"{self.id}_value = {self.id}_get{i}.execute({self.id}_index);")
            output.append(f"{res} = {res} & {self.id}_value;")
        return output

    def dump(self) -> List[str]:
        output = []
        output.append(f"// generated by _BloomFilter_{id(self)} start")
        output.append(f"bit<{self.index_width}> {self.id}_index;")
        output.append(f"bit<{self.elem_width}> {self.id}_value;")
        for i in range(self.n_tables):
            output.append(f"CRCPolynomial<bit<{self.index_width}>>({hex(randint(0, 0xFFFF))}, true, false, false, 0, 0) {self.id}_poly{i};")
            output.append(f"Hash<bit<{self.index_width}>>(HashAlgorithm_t.CRC{self.index_width}, {self.id}_poly{i}) {self.id}_hash{i};")
            output.append(f"Register<bit<{self.elem_width}>, bit<{self.index_width}>>({self.table_size}, 0) {self.id}_reg{i};")
            # upd
            output.append(f"RegisterAction<bit<{self.elem_width}>, bit<{self.index_width}>, bit<{self.elem_width}>>({self.id}_reg{i}) {self.id}_upd{i} = {'{'}")
            output.append(unit_indent + f"void apply(inout bit<{self.elem_width}> val, out bit<{self.elem_width}> res) {'{'}")
            output.append(unit_indent + unit_indent + "res = val;")
            output.append(unit_indent + unit_indent + "val = 1;")
            output.append(unit_indent + "}")
            output.append("};")
            # reset
            # output.append(f"RegisterAction<bit<{self.elem_width}>, bit<{self.index_width}>, void>({self.id}_reg{i}) {self.id}_reset{i} = {'{'}")
            # output.append(unit_indent + f"void apply(inout bit<{self.elem_width}> val) {'{'}")
            # output.append(unit_indent + unit_indent + "val = 0;")
            # output.append(unit_indent + "}")
            # output.append("};")
            # get
            output.append(f"RegisterAction<bit<{self.elem_width}>, bit<{self.index_width}>, bit<{self.elem_width}>>({self.id}_reg{i}) {self.id}_get{i} = {'{'}")
            output.append(unit_indent + f"void apply(inout bit<{self.elem_width}> val, out bit<{self.elem_width}> res) {'{'}")
            output.append(unit_indent + unit_indent + "res = val;")
            output.append(unit_indent + "}")
            output.append("};")
        output.append(f"// generated by _BloomFilter_{id(self)} end")
        return output

class _CountingBloomFilter(AssignTableBase):
    pass

class _MergeTable(RegisterTableBase):
    def __init__(self, resona_table : resona.RegisterTable):
        # TODO: select CM / C Sketch
        self.elem_width = resona_table.value_width
        self.id = resona_table.get_id()
        self._positive_cm_impl = _CountMinSketch_impl(
            id = self.id + "_pos",
            elem_width = self.elem_width,
            table_size = 1 << 16,
            index_width = 32,
            n_tables = 2,
        )
        self._negative_cm_impl = _CountMinSketch_impl(
            id = self.id + "_neg",
            elem_width = self.elem_width,
            table_size = 1 << 16,
            index_width = 32,
            n_tables = 2,
        )
    
    def set_table_size(self, table_size : int):
        self._positive_cm_impl.table_size = table_size
        self._negative_cm_impl.table_size = table_size

    def set_table_depth(self, table_depth : int):
        self._positive_cm_impl.n_tables = table_depth
        self._negative_cm_impl.n_tables = table_depth
    
    def get_elem_width(self):
        return self._positive_cm_impl.elem_width

    def update(self, key : str, op : str, value : str, hash_key : str, res) -> List[str]:
        assert op == 'add'
        # TODO: assert |value| == 1
        output = []
        output.append(f"if ({value} < 0) {'{'}")
        output += [unit_indent + line for line in self._negative_cm_impl.update(key, hash_key, res)]
        output.append("} else {")
        output += [unit_indent + line for line in self._positive_cm_impl.update(key, hash_key, res)]
        output.append("}")
        return output

    def query(self, key : str, res : str, hash_key : str) -> List[str]:
        output = self._positive_cm_impl.query(key, res, hash_key)
        output += self._negative_cm_impl.query(key, f"{self.id}_tmp", hash_key)
        output.append(f"{res} = {res} - {self.id}_tmp;")
        return output

    def dump(self) -> List[str]:
        output = []
        output.append(f"// generated by _MergeTable_{id(self)} start")
        output += self._positive_cm_impl.dump()
        output += self._negative_cm_impl.dump()
        output.append(f"bit<{self.elem_width}> {self.id}_tmp;")
        output.append(f"// generated by _MergeTable_{id(self)} end")
        return output


# TODO: 判断 reduce/assign
def _is_reduce_table(resona_table : resona.RegisterTable) -> bool:
    return resona_table.get_id().startswith('table_reduce_table')

def _is_assign_table(resona_table : resona.RegisterTable) -> bool:
    return resona_table.get_id().startswith('table_distinct_table')

def _is_merge_table(resona_table : resona.RegisterTable) -> bool:
    return resona_table.get_id().startswith('table_merge')

# TODO: Sketch 和 BloomFilter 的选择器，现在默认为 CM Sketch 和 BloomFilter
def _get_reduce_table(resona_table : resona.RegisterTable) -> ReduceTableBase:
    return _CountMinSketch(resona_table)

def _get_assign_table(resona_table : resona.RegisterTable) -> AssignTableBase:
    return _BloomFilter(resona_table)

def _get_udf_table(resona_table : resona.RegisterTable) -> RegisterTableBase:
    return None

def get_register_table(resona_table : resona.RegisterTable) -> RegisterTableBase:
    if _is_reduce_table(resona_table):
        return _get_reduce_table(resona_table)
    elif _is_assign_table(resona_table):
        return _get_assign_table(resona_table)
    elif _is_merge_table(resona_table):
        return _MergeTable(resona_table)
    else:
        return _get_udf_table(resona_table)