from backend.p4._template import unit_indent
from backend.p4._struct_definition import StructDefinitionFactory
from ir.ir import IRFactory, TransmitTable
from ir import resona
from backend.p4._register_table import RegisterTableBase, get_register_table, UDFTable
from backend.p4._statement import get_subtaskid_bitmap, get_statement
# from udf import sketch_ast
from typing import List, Dict

class _ValueFactory:
    def __init__(self):
        self.values : str = []
    
    def add_definition(self, id : str, type : str):
        self.values.append(f"{type} {id}")

    def add_value(self, id : str, width : int):
        self.add_definition(id, f"bit<{width}>")

    def add_const_value(self, id : str, width : int, value : str):
        self.values.append(f"const bit<{width}> {id} = {value}")

    def add_resona_value(self, resona_value_factory : resona.ValueFactory):
        for value in resona_value_factory.value_list:
            # TODO: var_task_mask
            if not value.get_id().startswith("var_task_mask"):
                self.add_value(value.get_id(), value.width)
        for (_, const) in resona_value_factory.const_dict.items():
            if const.name != "":
                self.add_const_value(const.get_id(), const.width, const.get_value())

    def dump(self, init_indent : str) -> str:
        output = f"{init_indent}// generated by _ValueFactory{id(self)} start\n"
        for value_definition in self.values:
            output += init_indent + value_definition + ";\n"
        output += f"{init_indent}// generated by _ValueFactory{id(self)} end\n"
        return output

class _TableFactory:
    def __init__(self, register_conf):
        self.tables = {}
        self.register_conf = register_conf

    def add_resona_table(self, resona_table_factory : resona.RegisterTableFactory):
        for resona_table in resona_table_factory.table_list:
            table = get_register_table(resona_table)
            if table != None:
                # TODO: 后四位不一致
                key = resona_table.get_id()[:-4]
                value = None
                for register_table in self.register_conf:
                    if register_table[:-4] == key:
                        value = self.register_conf[register_table]
                assert value != None
                table.set_table_size((16 << 10) * value["w"] * 8 // (table.get_elem_width()))
                table.set_table_depth(value["d"])
                self.tables[resona_table.get_id()] = table

    def add_udf_table(self, group : resona.StatementGroup):
        table_size = 0
        table_depth = 0
        for resona_table in group.registers:
            key = resona_table.get_id()[:-4]
            value = None
            for register_table in self.register_conf:
                if register_table[:-4] == key:
                    value = self.register_conf[register_table]
            assert value != None
            table_size = max(table_size, (16 << 10) * value["w"] * 8 // (resona_table.value_width))
            table_depth = max(table_depth, value["d"])
        table = UDFTable(group.original_op.func_name, table_size, table_depth)
        self.tables[group.original_op.func_name] = table
        # traverse group.statements
        _update_map = {
            "assign" : "{0} = {1};",
            "add" : "{0} = {0} + {1};",
            "minus" : "{0} = {0} - {1};"
        }
        _op_map = {
            "add" : "{} + {}",
            "minus" : "{} - {}"
        }
        if len(group.outs) > 0:
            table.output_width = group.outs[0].width
        vars = {}
        output = []
        def _parse_resona_statement(statement : resona.StatementBase, indent = ""):
            def parse_no_stateful(val):
                if isinstance(val, str):
                    if val[0].isdigit():
                        return val
                    else:
                        return "hdr." + val
                elif isinstance(val, list) and len(val) == 1 and isinstance(val[0], str):
                    return f"hdr.{val[0]}"
                else:
                    assert False, f"parse_no_stateful not support {val}"
            
            def _get_statement(val):
                _op_map = {"ge" : "{} - {} >= 0",
                        "eq" : "{} == {}",
                        "bit_and" : "({} & {}) != 0",
                        "gt" : "{1} - {0} < 0",
                        "lt" : "{} - {} < 0",
                        "ne" : "{} != {}"
                        }

                if isinstance(val, resona.StatementCompare):
                    if isinstance(val.left_value, resona.StatefullBase):
                        left = val.left_value.name
                        if not left in vars:
                            left = val.left_value.get_id()
                    else:
                        left = "hdr." + val.left_value
                    if isinstance(val.right_value, resona.StatefullBase):
                        right = val.right_value.name
                        if not right in vars:
                            right = val.right_value.get_id()
                    else:
                        right = "hdr." + val.right_value
                    return _op_map[val.op].format(left, right)
                else:
                    assert False, f"_get_statement() not support : {val.dump()}"

            if isinstance(statement, resona.StatementIf):
                output.append(indent + f"if ({_get_statement(statement.condition)}) {'{'}")
                for s in statement.true_list:
                    _parse_resona_statement(s, indent + unit_indent)
                if len(statement.false_list) >= 1:
                    output.append(indent + "} else {")
                    for s in statement.false_list:
                        _parse_resona_statement(s, indent + unit_indent)
                output.append(indent + "}")
            elif isinstance(statement, resona.StatementAssignment):
                left = statement.left_value.name
                vars[left] = statement.left_value.width
                if isinstance(statement.right_value, resona.StatefullBase) == False:
                    output.append(indent + f"{left} = {parse_no_stateful(statement.right_value)};")
                else:
                    output.append(indent + f"{left} = {statement.right_value.name};")
            elif isinstance(statement, resona.StatementRegisterAssignment):
                assert statement.return_value == None
                if isinstance(statement.key, str):
                    key = statement.key
                else:
                    key = statement.key.name
                    if not key in vars:
                        key = statement.key.get_id()
                output.append(indent + _update_map[statement.op].format("val."+statement.register_table.name, key))
            elif isinstance(statement, resona.StatementRegisterGet):
                left = statement.output.name
                vars[left] = statement.output.width
                output.append(indent + f"{left} = val.{statement.register_table.name};")
            elif isinstance(statement, resona.StatementSimpleCalc):
                vars[statement.result.name] = statement.result.width
                if isinstance(statement.left_value, resona.StatefullBase):
                    lstr = statement.left_value.name
                    if not lstr in vars:
                        lstr = statement.left_value.get_id()
                else:
                    lstr = statement.left_value
                    if not lstr[0].isdigit():
                        lstr = "hdr." + lstr
                if isinstance(statement.right_value, resona.StatefullBase):
                    rstr = statement.right_value.name
                    if not rstr in vars:
                        rstr = statement.right_value.get_id()
                else:
                    rstr = statement.right_value
                    if not rstr[0].isdigit():
                        rstr = "hdr." + rstr
                output.append(indent + f"{statement.result.name} = {_op_map[statement.op].format(lstr, rstr)};")
            else:
                assert False, f"udf not support: {type(statement)}"

        for statement in group.statements:
            _parse_resona_statement(statement, "")
        if len(group.outs) > 0:
            output.append(f"res = {group.outs[0].name};")
        for var in vars:
            table.register_action.append(f"bit<{vars[var]}> {var};")
        table.register_action += output
        return table

    def get_table(self, resona_table : resona.RegisterTable) -> RegisterTableBase:
        return self.tables[resona_table.get_id()]

    def dump(self, init_indent : str) -> str:
        output = f"{init_indent}// generated by _TableFactory{id(self)} start\n"
        for (_, table) in self.tables.items():
            for line in table.dump():
                output += init_indent + line + "\n"
        output += f"{init_indent}// generated by _TableFactory{id(self)} end\n"
        return output

class _StatementFacotry:
    def __init__(self, values: _ValueFactory, tables : _TableFactory, udfs, struct_definitions : StructDefinitionFactory):
        self.statements : List[str] = []
        self.analyzed_transmit_table : bool = False
        # UDF_OP_TRANS_DICT
        self._op_map = {
            "eq" : "{} == {}",
            "bit_and" : "({} & {}) != 0",
            "lt" : "{} < {}",
            "gt" : "{} > {}",
            "ne" : "{} != {}",
            "ge" : "{} >= {}",
            "le" : "{} <= {}",
            "add" : "{} + {}",
            "minus" : "{} - {}"
        }
        self.values = values
        self.tables = tables
        self.hash_map : Dict[str, str] = {}
        self.struct_definitions = struct_definitions
        # self.udfs = {}
        # {"code":code, "total_states":total_states, "root":root}
        # for udf in udfs:
            # self.udfs[udf["root"].func_name] = (udf["total_states"], udf["root"])
            # print("code:\n", udf["code"])
            # print("total_states\n", udf["total_states"])
            # print("root:\n")
            # udf["root"].show(0)

    def analyze_transmit_table(self, table : TransmitTable):
        assert not self.analyzed_transmit_table
        self.analyzed_transmit_table = True
        self.statements.append(f"var_task_mask = 0;")
        def dfs_table(table : TransmitTable, indent : str):
            for unit in table.compunit:
                # TODO: get subtaskid
                self.statements.append(f"{indent}var_task_mask = var_task_mask | {get_subtaskid_bitmap(unit.factory.ops[1].filter_branch)};")
            for (iter, subtables) in table.table.items():
                (key_name, op) = iter
                for (value, subtable) in subtables.items():
                    self.statements.append(f"{indent}if ({self._op_map[op].format(f'hdr.{key_name}', value)}) {'{'}")
                    dfs_table(subtable, indent + unit_indent)
                    self.statements.append(indent + "}")
        dfs_table(table, "")
        # if len(self.udfs) != 0:
        #     self.statements.append("flow_fingerprint = crc32.get({hdr.ipv4.src_addr, hdr.ipv4.dst_addr, hdr.tcp.src_port, hdr.tcp.dst_port});")
        self.statements.append("")

    def _parse_resona_statement(self, statement : resona.StatementBase, indent = ""):
        def parse_no_stateful(val):
            if isinstance(val, str):
                if val[0].isdigit():
                    return val
                else:
                    return "hdr." + val
            elif isinstance(val, list) and len(val) == 1 and isinstance(val[0], str):
                return f"hdr.{val[0]}"
            else:
                assert False, f"parse_no_stateful not support {val}"

        if isinstance(statement, resona.StatementCompare):
            assert False, "_parse_resona_statement not support StatementCompare"
        elif isinstance(statement, resona.StatementIf):
            self.statements.append(indent + f"if ({get_statement(statement.condition)}) {'{'}")
            self.add_resona_statements(statement.true_list, indent + unit_indent)
            if len(statement.false_list) >= 1:
                self.statements.append(indent + "} else {")
                self.add_resona_statements(statement.false_list, indent + unit_indent)
            self.statements.append(indent + "}")
        elif isinstance(statement, resona.StatementAssignment):
            if isinstance(statement.right_value, resona.StatefullBase) == False:
                self.statements.append(indent + f"{statement.left_value.get_id()} = {parse_no_stateful(statement.right_value)};")
            else:
                self.statements.append(indent + f"{statement.left_value.get_id()} = {statement.right_value.get_id()};")
        elif isinstance(statement, resona.StatementRegisterAssignment):
            register_table = self.tables.get_table(statement.register_table)
            if isinstance(statement.key, str):
                key = statement.key
            else:
                key = statement.key.get_id()
            if statement.return_value == None:
                res = None
            else:
                res = statement.return_value.get_id()
            self.statements += [indent + line for line in register_table.update(statement.index.get_id(), statement.op, key, self.hash_map.get(statement.index.get_id(), ""), res)]
        elif isinstance(statement, resona.StatementRegisterGet):
            register_table = self.tables.get_table(statement.register_table)
            self.statements += [indent + line for line in register_table.query(statement.index.get_id(), statement.output.get_id(), self.hash_map.get(statement.index.get_id(), ""))]
        elif isinstance(statement, resona.StatementCalcIndex):
            tmp = ""
            for input in statement.inputs:
                if isinstance(input, str):
                    tmp += f"hdr.{input}, "
                else:
                    tmp += f"{input.get_id()}, "
            self.hash_map[statement.output.get_id()] = '{' + tmp[:-2] + '}'
            if len(statement.inputs) > 1:
                self.values.add_definition(statement.output.get_id() + "_crc32", "Hash<bit<32>>(HashAlgorithm_t.CRC32)")
                self.statements.append(indent + f"{statement.output.get_id()} = {statement.output.get_id()}_crc32.get({'{' + tmp[:-2] + '}'});")
            else:
                self.statements.append(indent + f"{statement.output.get_id()} = {tmp[:-2]};")
        # elif isinstance(statement, resona.StatementGroupBy):
            # self.statements.append(indent + "{" + f" //groupby[{statement.dump()[:-1]}] start")
            # udf_states, udf_ast = self.udfs[statement.groupby_op.func_name]
            # assert len(udf_states) == len(statement.registers), f"{udf_states} len!= {statement.registers}"
            # assert len(udf_ast.params) == len(statement.groupby_op.args), f"{udf_ast.params} len!= {statement.groupby_op.args}"
            # param_var_map = {}
            # for value in statement.outputs:
                # var = value.get_id()
                # var_{name}_xxxx
                # param = var[4:-5]
                # param_var_map[param] = var
            # for register_table in statement.registers:
                # table_{name}_xxxx
                # register = register_table.get_id()
                # param = register[6:-5]
                # assert param in udf_states
                # if not param in param_var_map:
                    # var = register[6:]
                    # self.statements.append(indent + f"bit<{self.tables.get_table(register_table).elem_width}> {var};")
                    # param_var_map[param] = var
                # else:
                    # var = param_var_map[param]
                # self.statements += [indent + line for line in self.tables.get_table(register_table).query("flow_fingerprint", var)]
            # for param, var in zip(udf_ast.params, statement.groupby_op.args):
                # if var.find('.') != -1:
                    # param_var_map[param] = "hdr." + var
                # else:
                    # param_var_map[param] = var
# 
            # def dfs_udf_ast(ast : sketch_ast.BaseAst, indent : str) -> str | None:
                # if isinstance(ast, sketch_ast.IdentifierAst):
                    # if ast.identifier in param_var_map:
                        # return param_var_map[ast.identifier]
                    # else:
                        # if ast.identifier.find('.') != -1:
                            # return "hdr." + ast.identifier
                        # else:
                            # return ast.identifier
                # elif isinstance(ast, sketch_ast.NumberAst):
                    # return str(ast.number)
                # elif isinstance(ast, sketch_ast.AssignAst):
                    # self.statements.append(indent + f"{dfs_udf_ast(ast.identifier, indent)} = {dfs_udf_ast(ast.exp, indent)};")
                # elif isinstance(ast, sketch_ast.FunDefAst):
                    # dfs_udf_ast(ast.body, indent)
                # elif isinstance(ast, sketch_ast.IfAst):
                    # self.statements.append(indent + f"if ({dfs_udf_ast(ast.cond, indent)}) " + '{')
                    # if ast.then != None:
                        # dfs_udf_ast(ast.then, indent + unit_indent)
                    # if ast.else_then != None:
                        # self.statements.append(indent + "} else {")
                        # dfs_udf_ast(ast.else_then, indent + unit_indent)
                    # self.statements.append(indent + '}')
                # elif isinstance(ast, sketch_ast.BinaryExpAst):
                    # return f"({dfs_udf_ast(ast.lhs, indent)} {ast.op} {dfs_udf_ast(ast.rhs, indent)})"
                # elif isinstance(ast, sketch_ast.UnaryExpAst):
                    # return f"({ast.op} {dfs_udf_ast(ast.opr, indent)})"
                # elif isinstance(ast, sketch_ast.BlockAst):
                    # for item in ast.items:
                        # dfs_udf_ast(item, indent)
                # else:
                    # assert False, f"ast type not support ({type(ast)})"
            # dfs_udf_ast(udf_ast, indent)
# 
            # for register_table in statement.registers:
                # table_{name}_xxxx
                # register = register_table.get_id()
                # param = register[6:-5]
                # var = param_var_map[param]
                # self.statements += [indent + line for line in self.tables.get_table(register_table).update("flow_fingerprint", "assign", var)]
# 
            # self.statements.append(indent + "}" + f" //groupby[{statement.dump()[:-1]}] end")
        elif isinstance(statement, resona.StatementSetEgressPort):
            self.statements.append(indent + f"ig_tm_md.ucast_egress_port = {statement.egress_port.get_value()};")
        elif isinstance(statement, resona.StatementSimpleCalc):
            if isinstance(statement.left_value, resona.StatefullBase):
                lstr = statement.left_value.get_id()
            else:
                lstr = statement.left_value
            if isinstance(statement.right_value, resona.StatefullBase):
                rstr = statement.right_value.get_id()
            else:
                rstr = statement.right_value
            self.statements.append(indent + f"{statement.result.get_id()} = {self._op_map[statement.op].format(lstr, rstr)};")
        elif isinstance(statement, resona.StatementGroup):
            assert len(statement.outs) <= 1
            self.statements.append(indent + f"ig_md.fingerprint = {statement.index.get_id()};")
            table = self.tables.add_udf_table(statement)
            if len(statement.outs) == 0:
                self.statements += [indent + line for line in table.action(None, self.hash_map.get(statement.index.get_id(), statement.index.get_id()))]
            else:
                self.statements += [indent + line for line in table.action(statement.outs[0].get_id(), self.hash_map.get(statement.index.get_id(), statement.index.get_id()))]
            assert len(statement.registers) >= 1
            struct = self.struct_definitions.add_struct(f"{table.name}_t")
            for register in statement.registers:
                struct.add_member(register.name, f"bit<{register.value_width}>")
        else:
            assert False, f"not support: {type(statement)}"

    def add_resona_statements(self, resona_statements : List[resona.StatementBase], indent = ""):
        for statement in resona_statements:
            self._parse_resona_statement(statement, indent)

    def dump(self, init_indent : str) -> str:
        assert self.analyzed_transmit_table
        output = f"{init_indent}// generated by _StatementFactory{id(self)} start\n"
        for statement in self.statements:
            output += init_indent + statement + '\n'
        output += f"{init_indent}// generated by _StatementFactory{id(self)} end\n"
        return output

class SwitchEgressFactory:
    def __init__(self, struct_definitions : StructDefinitionFactory, ir : IRFactory, udfs, register_conf):
        self.value = _ValueFactory()
        self.table = _TableFactory(register_conf)
        self.statements = _StatementFacotry(self.value, self.table, udfs, struct_definitions)

        # if len(udfs) != 0:
            # self.value.add_value("flow_fingerprint", 32)
            # self.value.add_value("flow_fingerprint_hit", 1)

        self.value.add_value("var_task_mask", 32)
        self.statements.analyze_transmit_table(ir.table)
        for (_, compunit) in enumerate(ir.compuints):
            self.value.add_resona_value(compunit.resona.value_factory)
            self.table.add_resona_table(compunit.resona.table_factory)
            self.statements.add_resona_statements(compunit.resona.statements)

    def dump(self, init_indent : str) -> str:
        output = f"{init_indent}// generated by SwitchEgressFactory{id(self)} start\n"
        output += self.value.dump(init_indent) + '\n'
        output += self.table.dump(init_indent) + '\n'
        output += f"{init_indent}apply {'{'}\n"
        output += init_indent + unit_indent + "tab_forward.apply();\n"
        output += f"{self.statements.dump(init_indent + unit_indent)}{init_indent}{'}'}\n"
        output += f"{init_indent}// generated by SwitchEgressFactory{id(self)} end\n"
        return output